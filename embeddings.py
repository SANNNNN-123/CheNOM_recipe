
import json
from supabase import create_client
from openai import OpenAI

supabase = create_client(
    supabase_url="YOUR_SUPABASE_URL",
    supabase_key="YOUR_SUPABASE_KEY"
)
client = OpenAI(api_key="YOUR_OPENAI_API_KEY")

def get_embedding(text):
    response = client.embeddings.create(
        model="text-embedding-ada-002",
        input=text
    )
    return response.data[0].embedding

def process_recipe(recipe):
    # Extract ingredients list
    ingredients = [item.lower() for sublist in recipe['details']['ingredients'].values() 
                  for item in sublist]
    
    text_to_embed = f"""
    Title: {recipe['title']}
    Ingredients: {', '.join(ingredients)}
    Instructions: {' '.join([step for sublist in recipe['details']['instructions'].values() 
                           for step in sublist])}
    """.strip()

    embedding = get_embedding(text_to_embed)

    data = supabase.table('recipes').insert({
        'title': recipe['title'],
        'content': text_to_embed,
        'ingredients': ingredients,
        'embedding': embedding,
        'raw_data': recipe
    }).execute()

    return data

def process_recipe_file(file_path):
    try:
        with open(file_path, 'r', encoding='utf-8') as file:
            recipes = json.load(file)
        
        for recipe in recipes:
            result = process_recipe(recipe)
            print(f"Processed recipe: {recipe['title']}")
            
    except Exception as e:
        print(f"Error processing recipes: {str(e)}")

process_recipe_file('data/recipe_titles_telur_11.json')



#in supabase, the table is called recipes

#---create table recipes in supabase---
# create table recipes (
#   id bigint generated by default as identity primary key,
#   title text,
#   content text,
#   ingredients text[], -- Add this column
#   embedding vector(1536),
#   raw_data jsonb
# );

#---create function match_recipes in supabase---
# create or replace function match_recipes (
#   query_embedding vector(1536),
#   match_threshold float,
#   match_count int
# )
# returns table (
#   id bigint,
#   title text,
#   ingredients text[],
#   similarity float
# )
# language plpgsql
# as $$
# begin
#   return query
#   select
#     recipes.id,
#     recipes.title,
#     recipes.ingredients,
#     1 - (recipes.embedding <=> query_embedding) as similarity
#   from recipes
#   where 1 - (recipes.embedding <=> query_embedding) > match_threshold
#   order by similarity desc
#   limit match_count;
# end;
# $$;


def search_similar_recipes(ingredients, match_threshold=0.7, limit=3):
    # Create embedding for search query
    search_text = f"Ingredients: {', '.join(ingredients)}"
    embedding = client.embeddings.create(
        model="text-embedding-ada-002",
        input=search_text
    ).data[0].embedding

    # Query Supabase using vector similarity
    query = supabase.rpc(
        'match_recipes',  # We'll create this function
        {
            'query_embedding': embedding,
            'match_threshold': match_threshold,
            'match_count': limit
        }
    ).execute()

    return query.data

# Example usage
ingredients = ['rice', 'chicken', 'carrot']
similar_recipes = search_similar_recipes(ingredients)
for recipe in similar_recipes:
    print(f"Recipe: {recipe['title']}")
    print(f"Similarity Score: {recipe['similarity']}")
    print(f"Ingredients: {recipe['ingredients']}\n")